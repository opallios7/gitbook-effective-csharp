# Item #23 클래스 내부 객체에 대한 reference 반환을 피하라.

readonly로 정의된 프로퍼티는 읽기전용으로 선언되었기 때문에 외부에서 이 값을 변경하는 것이 불가능하다고 생각하겠지만, 불행히도 항상 그런것은 아니다. 만일 프로퍼티가 특정 객체에 대한 reference를 반환하게 되면 외부에서는 반환된 reference를 통하여 public 메소도를 호출할 수 있고, 이 경우 객체의 내부 상태를 변경할 수 있다. 다음의 예제를 보자.

```
public class MyBusinessObject
{
    private DataSet _ds;
    public DataSet Data
    {
        get
        {
            return _ds;
        }
    }
}


DataSet ds = bizObj.Data;
ds.Tables.Clear(); // DataSet 내의 모든 테이블이 삭제된다.
```

MyBusinessObject를 사용하는 모든 사용자는 내부의 DataSet 객체의 내용을 얼마든지 수정할 수 있다. 따라서 이러한 프로퍼티를 정의할 때는 반드시 내부적인 자료의 타입을 숨기는 것이 좋다. 대신 사용자가 내부자료를 사용할 수 있도록 추가적인 메소드를 구성하여 노출함으로써, 객체의 내부상태가 의도하지 않은 상태로 변경되지 않도록 해야 한다.

객체에 대한 reference를 외부로 반환하면, 사용자를 객체를 수정할 수 있는 기회를 얻게된다. 만일 특정타입을 만들때 내부자료를 수정할 수 있는 메소드를 만들어 두었다 하더라도, 내부자료에 대한 reference를 직접적으로 획득할 수 있는 방법이 있다면 사용자를 더이상 그러한 메소드를 이용하는 간접적인 방법을 사용하지 않을 것이다.

실제로 객체의 내부자료에 대하여 우리가 의도하지 않은 변경이 일어나는 것을 막는 데는 4가지 정도의 훌륭한 전략이 있다. value 타입, immutable타입, interface 그리고 wrapper를 활용하는 방법이다.

## 결론
> 특정 타입을 구현할 때 reference 타입 객체를 public 필드로 선언하여 외부에서의 직접 접근을 허용하면, 사용자는 우리가 구현하는 타입에서 정의한 메소드나 프로퍼티를 이용하여 간접적으로 내부자료에 접근하려 하지 않고 직접 내부 데이터를 변경하려고 시도할 것이다. 이 경우 매우 발견하기 어려운 오류를 유발할 가능성이 있다. reference타입을 private로 선언하고 프로퍼티나 특정 메소드의 반환값으로만 사용한다 하더라도 사용자는 반환된 객체 내의 public 필드를 무제한으로 사용할 수 있다. 따라서 private로 선언된 reference타입 객체를 노출할 경우에는 interface를 사용하거나 wrapper class를 생성하여 접근권한을 제한할 필요가 있다. 만일 사용자가 내부자료에 변경을 가하는 것을 허용해야 하는 경우라면 내부자료의 변경이 유요한 변경인지를 검토하기 위해서는 Observer 패턴을 구현하는 것이 좋다.